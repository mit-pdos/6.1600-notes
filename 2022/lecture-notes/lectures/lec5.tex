In the last section, our strategy for
authentication depended on two parties sharing a
secret key.
In that discussion, we completely left
out of the picture how these parties should
exchange this secret key.
Our implication was that they
went to some private room and exchanged the key in
secret, but in many cases this is not practical:
if they could whisper a key, why not just whisper the message?

Luckily, there is a way to get around this requirement for a shared secret using \emph{public-key cryptography}.\cite{DH76} % TODO: cite DH
\marginnote{The original Diffie-Hellman paper from 1976, which introduced
public-key cryptography, is a fascinating read.}

\section{Definitions}
The basic idea of public-key cryptography, applied
to authentication, is that each party will
generate two linked keys---a secret signing key
and a public verification key.
The verification key will be good enough to verify that a signature
is valid, but not to generate new signatures.

\begin{definition}[Signature Scheme]
	A signature scheme is associated with a message space $\calM$ and three efficient algorithms $(\Gen, \Sign, \Ver)$.

      \marginnote{In theoretical papers, people will write $\Gen(1^\lambda)$ to indicate that the key-generation
      algorithm takes as input a length-$\lambda$ string of ones.
      This is just a hack to make the input given to $\Gen$ $\lambda$ bits long so that the
      $\Gen$ algorithm can run in time polynomial in its input length: $\poly(\lambda)$.
      If we express $\lambda$ in binary, then $\Gen(\lambda)$ gets a $\log_2 \lambda$-bit input
      and can only run in time $\poly(\log \lambda)$.
      This distinction is really unimportant, but if you see the $1^\lambda$ notation, you will
      now know what it means.}
	\begin{itemize}
    \item $\Gen(\lambda) \to (\sk, \vk)$.
      The key-generation algorithm as input a security parameter $\lambda \in \N$ and outputs a secret signing key $\sk$ and public verification key $\vk$.
      The algorithm $\Gen$ runs in time $\poly(\lambda)$.
    \item $\Sign(\sk, m) \to \sigma$.
      The signing algorithm takes as input a secret key $\sk$ and a message $m \in \calM$, and outputs a signature $\sigma$.
    \item $\Ver(\vk, m \sigma) \to \zo$.
      The signature-verification algorithm takes as input a public verification key $\vk$, a message $m \in \calM$, and a signature $\sig$, 
      and outputs $\bin$, indicating acceptance or rejection.
	\end{itemize}
	
\end{definition}

For a signature to be useful, a correct verifier must always accept messages from an
honest signer. Formally, we have:

\begin{definition}[Digital signatures: Correctness]
  For all $\lambda \in \N$, for all messages $m \in \calM$:
  \[ \Pr\big[\Ver(\vk, m, \Sign(\sk, m)) = 1 \colon (\sk, \vk) \gets \Gen(\lambda) \big] = 1. \]
\end{definition}

The standard security notion for digital signatures is very similar
to that for MACs (\cref{def:mac-sec}).
The only difference here is that a digital-signature scheme splits the single
secret MAC key into two keys: a secret signing key and a public verification key.
Otherwise the definition is essentially identical.

\begin{definition}[Digital signatures: Security -- existential unforgeability under chosen message attack]\label{def:sig-sec}
  All efficient adversaries $\calA$ win the following security 
  game with only negligible probability:
  \begin{itemize}[noitemsep]
    \item The challenger runs $(\sk, \vk) \gets \Gen(\lambda)$ and sends $\vk$ to the adversary.
    \item For $i = 1, 2, \dots$  (polynomially many times)
      \begin{itemize}
        \item The adversary sends a message $m_i \in \calM$ to the challenger.
        \item The challenger replies with $\sigma_i \gets \Sign(\sk, m_i)$.
      \end{itemize}
    \item The adversary outputs a message-signature pair $(m^*, \sigma^*)$.
    \item The adversary wins if $\Ver(\vk, m^*, \sigma^*) = 1$ and $m^* \not \in \{m_1, m_2, \dots\}$.
  \end{itemize}
\end{definition}

Notice that the security definition here allows an attacker, given a valid
message-signature pair $(m, \sigma)$ to produce additional valid message-signature
pairs on the same message: $(m, \sigma'), (m, \sigma''), \dots$.
Standard digital-signature schemes, such as the elliptic-curve digital signature
algorithm (EC-DSA) have this property.

In some applications, we want to prohibit an attacker from finding \emph{any}
new message-signature pair. We call this security notion ``\emph{strong} existential unforgeability under chosen message attack.'' 

The definition is the same as in \cref{def:sig-sec} except that we require
the adversary to find a valid-message signature pair $(m^*, \sigma^*)$
such that $(m^*, \sigma^*) \not \in \{ (m_1, \sigma_1), (m_2, \sigma_2), \dots \}$.

\section{Constructing a Signature Scheme}
In the following sections, we will show how to construct a digital-signature
scheme from one-way functions.

We will generate a signature scheme that is secure, but is not practical. For pracical signature schemes, see RSA et al. We will construct this scheme in three stages:

\begin{enumerate}
	\item Construct a \emph{one-time secure} signature scheme for \emph{bounded messages}, where the security can be broken if an adversary sees more than a single signature and where $\abs{\sk} > \abs{m}$ (the size of the secret key is larger than the size of the message). This is called the Lamport Scheme. %TODO: cite
	\item Construct a one-time secure scheme for messages in $\bin^*$, removing the restriction that the secret key is longer than the message.
	\item Construct a many-time secure scheme for messages in $\bin^*$.
\end{enumerate}

\begin{definition}[One-Time Security]
	A signature scheme is one-time secure if $\forall \ppt \A$ wins the following game with negligible probability:

	The challenger generates $(\sk, \vk) \leftarrow \Gen(1^\lambda)$ and sends $\vk$ to the adversary. The adversary can then ask for a \emph{single} signature over a message $m$, and the challenger must respond with $\sig = \Sign(\sk, m)$. $\A$ wins if he outputs $(m^*, \sig^*)$ where $\Ver(\vk, m^*, \sig^*) = 1$ and $m^* \neq m$.
\end{definition}

% TODO: why we are defining one-way 

\begin{definition}[One-Way]
	A function $f: X \rightarrow Y$ is one-way if it is poly-time computable and the probability of an adversary given $y=f(x)$ finding $x$ such that $f(x) = y$ is negigible. Formally,

	% TODO: probability function, formalize notation here
	\[ \forall \ppt \A, \exists \mu(\lambda) \text{s.t. } \text{Pr}_{x \leftarrow X, y = f(x)}\left[\A(y) = x' \text{s.t.} f(x')=y\right] \leq \mu(\lambda) \]
\end{definition}

\subsection{Lamport Signature Scheme}
We first construct a one-time secure signature scheme for messages in $\bin^n$. To do this, we will define the following algorithms:


\begin{itemize}
	\item Choose at random, with elements sampled from $X$, and where $f$ is a one-way function.

\[ \sk = \begin{pmatrix}
	x_{10} & \ldots & x_{n0} \\
	x_{11} & \ldots & x_{n1} \\
	\end{pmatrix}, \vk = \begin{pmatrix}
	f(x_{10}) & \ldots & f(x_{n0}) \\
	f(x_{11}) & \ldots & f(x_{n1}) \\
\end{pmatrix}\]
	\item $\Sign(\sk, m)$ outputs $(x_{1m_1}, \ldots x_{nm_n})$, where $m_1 \ldots m_n$ are the individual bits of the length-$n$ message $m$.
	\item $\Ver(\vk, m, \sig)$ parses $\sig$ into its individual bits $\sig = (x_1^*, \ldots x_n^*)$ and $\sig$ into the matrix above. Accept if the application of the one-way function $f$ to each bit $i$ of the signature matches the corresponding value in the verification key. In math terms, output 1 if $\forall i \in [n], f(x^*_i) = \vk_{im_i}$, and otherwise output 0.
\end{itemize}

This scheme is obviously impractical since the keys are so large, and if an adversary can ask for two messages there is an obvious attack: the adversary should first ask for $0^n$ and recieve $\sig_1 = (x_{10}, \ldots, x_{n0})$, and then ask for the signature of $m_2 = 1^n$ and recieve $\sig_2 = (x_{11}, \ldots, x_{n1})$. At this point, the adversary can reconstruct the entire secret key $\sk = \begin{smallmatrix} \sigma_1 \\ \sig_2 \end{smallmatrix}$! However, we will argue that if the adversary can see only a single message, this scheme is indeed secure.

\textbf{Claim:} This scheme is one-time secure assuming $f$ is a one-way function.

In cryptography, they way we generally do these proofs is by \emph{reduction}---we will show that \emph{if an adversary exists that breaks the security}, then we can construct an adversary to break one of our assumptions. If we do this, there is a contradiction, so the first adversary cannot exist.

\textbf{Proof (sketch):} Suppose there exists an adversary $\A$ that wins the game in our security definition with non-negligible probability, meaning that the adversary can generate $(m^*, \sig^*)$ such that $\Ver(\vk, m^*, \sig^*) = 1$ and $m \neq m^*$ given only $\sig_1 = \Sign(\sk, m_1)$. We can then construct an adversary $\B$ that can use $\A$ to break the one-way function.

% TODO: Fix this. I didn't have time to write it well/finish it
First, $\B$ should generate a key pair ($\B$ is the challenger in this case.

Since $m \neq m^*$ and $\sig$ in this scheme depends on the bits of $m$, it must be the case that $\sig^*$ varies from $\sig_1$ in at least one bit. Therefore, the adversary has some value of the secret key matrix that was not given to them as part of $\sig_1$ and the corresponding value of


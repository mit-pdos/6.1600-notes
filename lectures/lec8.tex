So far, we have explored methods for authenticating data---verifying that it has not been modified since it was sent by some trusted party. However, all of these strategies have allowed the attacker to view everything that was sent. Often, this is undesirable. 

For last time, we were generally thinking about \emph{receiving} a message from the network---the message could have come from anyone and we would like to ensure that it came from someone we trust. For this, tools like hashing, MACs, and signature schemes are very useful.

However, in reality, we send messages on the network as well. And typically, everyone on the network can see the packets that are sent. Tools like \ttt{tcpdump} allow anyone who happens to be on the same network to see the traffic. To avoid leaking all of our sensitive information, we need a property called \emph{confidentiality}---and for that, we need \emph{encryption}.

% TODO: demo of tcpdump output would be cool

In this chapter, we will construct a weak version of security for fixed-length messages with a shared key. We will expand this to achieve stronger encryption for variable-length essages, and later to achieve this without a shared key. Finally, we will discuss encryption for streams such as HTTPS and think about some problems that encryption does not solve.

\section{Network Structure}
The internet is a massive network of wifi access points, routers, switches, undersea cables, DNS servers, and much more. There are many, many devices for a potential adversary to compromise and see network traffic: ever single hop your packets take is vulnerable.

To make matters worse, most standard network protocols provide no authentication or encryption: in Ethernet, IP, DNS, email, HTTP, and others, an adversary is free to change and view the content we send and recieve.

\section{Systems using Encryption}
Because these protocols do not provide security guarantees, applications built on top of them use encryption. For messaging, such as WhatsApp, Signal, and iMessage, services use encryption to guarantee that a malicious network and even a malicious server cannot view or modify your messages. In interactive streams like HTTPS and SSH, encryption is used to ensure that attackers in the network between you and the server cannot view or modify your traffic. Encryption is also commonly used in file encryption, such as full-disk encryption or encrypting for untrusted cloud providers.

\section{Encryption Scheme Syntax}
Encryption schemes are defined in terms of a key space $\calK$, a message space $\calM$, and a ciphertext space $\calC$, where each is typically $\bin^n$ for a security parameter $n$. There are two necessary algorithms:

\begin{itemize}
	\item $\Enc: \calK \times \calM \rightarrow \calC$
	\item $\Dec: \calK \times \calC \rightarrow \calM$ (this can also output, as we will see later, \textquote{FAIL} or $\bot$.
\end{itemize}

\begin{definition}[Encryption Scheme, Correctness]
	An encry[tion scheme is correct if, for all keys $k \in \calK$ and all messages $m \in \calM$, $\Dec(k, \Enc(k, m)) = m$.
\end{definition}

This correctness property guarantees that the scheme is useful for honest parties. To guarantee that it helps thwart attackers, we will define security in similar terms as we did for authentication. 

As a candidate security definition, consider the following: \emph{an eavesdropper who sees many encryptions, no adversary exists that can output a plaintext and new ciphertext}.

This definition, however, allows encryption schemes that leake a single bit of the message. To patch this, we could try to add a property that an adversary cannot guess any individual bit of the message, but this then admits schemes that allow an attacker to learn some function of the message bits such as their parity.

\begin{definition}[Encryption Scheme, Security (weak): Indistinguishability under adaptive chose plaintext attack ($\INDCPA$)]
	Intuitively, a scheme is CPA secure if an attacker cannot tell which of two chosen messages are encrypted, even after seeing many encryptions on chosen messages.

	Formally, an encryption scheme $(\Enc, \Dec$) is CPA-secure if for all efficient adversaries $\calA$, $\calA$ wins the following game with probability at most $\tfrac{1}{2}$ + negligible:

	\begin{enumerate}
		\item The challenger samples $b \rgets \bin$ and $b \rgets \calK$.
		\item $\calA$ then chooses $m_i^0$ and $m_i^1 \in \calM$ and sends them to the challenger. The challenger responds with $c_i = \Enc(k, $m_i^b)$. This can be repeated for polynomially many $i$.
		\item $\calA$ outputs a value $b' \in \bin$, and wins if $b'=b$ with probability $\geq \tfrac{1}{2} + \mu(n)$, where $\mu$ is some negligible function.
	\end{enumerate}
\end{definition}

Notably, for an encryption scheme to be secure in any meaningful sense, it must be randomized. Otherwise, an adversary can learn the encryption of two known messages and use these to decrypt future messages. This not only allows breaking the above definition, but is very applicable to real use cases as well. MACs, on the other hand, can (and typically are) deterministic.

\section{One-time Pad}
As a first attempt at constructing an encryption scheme, consider the scenario where Alice and Bob both know some shared key $k \in \bin^n$ and Alice would like to send bob a message $m \in \bin^n$. In this scenario, Alice can compute the ciphertext as $c = k \xor m$ and send $c$ to Bob over the network. Bob can then recover the message as $m \leftarrow c \xor k$. In some sense, this provides perfect security: since the key is sampled at random, each bit of the message becomes indistinguisable from random in the ciphertext to an attacker that does not know the key. And this scheme is indeed perfectly secure, even against attackers with unbounded computational power, as long as \emph{the key is only used once}.

If two ciphertexts are ever computed using the same key, $c_1 = m_1 \xor k$ and $c_2 = m_2 \xor k$, an attacker can trivially learn the XOR of the two messages via the associativity of XOR, something called a \emph{two-time attack}:

\[ c_1 \xor c_2 = m_1 \xor k \xor m_2 \xor k = m_1 \xor m_2 \]

This scheme seems in some sense useless: if a secure channel exists through which Alice and Bob can exchange a key $k$ of length $n$, they may as well use that channel to exchange the message itself! There is some merit, given that the key can be exchanged ahead of time, and indeed this was used by diplomats who exchanged a huge book of one-time pads and used it to communicate securely over long distances. However, in any practical setting, this is insuffient. For an encryption scheme to be useful, we need to be able to exchange some short key and use that key for many messages.

\section{A Weak Encryption Scheme}
If we want to make use of the one-time pad strategy to achieve this, what we effectively need is a way to generate many bits of random-looking keys from a single random string. To generate this, we can use a pseudorandom function! In particular, we would like a PRF of the form $F: \bin^n \times \bin^n \rightarrow \bin^n$. 

Using such a PRF, we can construct a new scheme building on the one-time pad:

\begin{itemize}
	\item $\Enc(k, m_i)$: Sample some randomness $r_i \rgets \bin^n$ and use it to compute a one-time key $k_i \gets F(k, r_i)$. Use this key to compte the ciphertext using the one-time pad above, $c_i = m_i \xor k$.
	\item $\Dec(k, c_i)$: Compute $m_i \gets c_i \xor F(k, r_i)$
\end{itemize}

Importantly, the probability of two $r_i$s being equal must be negligibly small. If two $r_i$ values are ever equal, the pad used to generate the cipher text will be identical. Since the $r$ values are public, an attacker can easily detect this and apply the same two-time attack to recover the XOR of the two messages. As we have seen before in the birthday paradox, if our key space is of size $2^{128}$, we can expect a collision in 128-bit random values once around $2^{64}$ have been generated. Therefore, any single key must be used for $\ll 2^{64}$ messages. In practice, this means that encryption schemes will have some key rotation mechanism built in that allows the parties to switch to a new key as necessary.

\subsection{Security Intuition}
In this scheme, the attacker sees pairs $\set{(r_1, m_1 \xor F(k, r_1), \ldots, (r_T, m_T \xor F(k, r_T))}$, where $k \rgets \calK$ is random. By our definition of PRF security, all $F(k, r_i)$ \textquote{look random} from the perspective of a PPT attacker. Therefore, we can replace each $F(\cdot)$ with a random value. This is then equivalent to the one-time pad presented above, and is secure as long as each $F(\cdot)$ is unique.

	However, note that this is a \emph{weak} signature scheme. First, it says nothing about message integrity: an attacker can modify the ciphertext and potentially meaningfully change the meaning of the resulting decryption---if the attacker modifies the ciphertext $c' = c \xor \Delta$, the resulting message will be $m' = c \xor \Delta$. Importantly, if the attacker knows the structure of the message, this allows them to flip important bits of the message.

	The CPA security definition also restricts the attacker's power to requesting encryptions of plaintext messages. It does not guarantee anything if the attacker can see decryptions of ciphertexts of its choice. In practice, this is quite a feasible thing for an attacker to do: for example, in a system where a client sends encrypted messages to a server and the server does something in response, an attacker can send encrypted queries to the server and observe its behavior to learn some function of the decrypted contents of the message. Next time, we will expand our definition to include these \textit{chosen ciphertext attacks}.

In the last chapter, we discussed digital
signatures, which allow us to authenticate messages
without a shared secret.
For example, if I have the public signature-verification key 
of the university dean, I can verify that signed emails from 
the dean really came from her and not from someone pretending to be her.
But to verify the signature on the dean's message, I need to know her
signature-verification key $\vk$.
How can I (the recipient) obtain this verification key without
a secure channel to the dean (the sender)?

Unfortunately, there are no perfect solutions to this problem.
In this section, we will discuss some of the approaches that
we use in practice.

\section{Public-key infrastructure}

The goal of a public-key infrastructure is to facilitate
the mapping of \textbf{human-intelligible names} to
\textbf{signature-verification keys}.
Examples of human-intelligible names that we map to keys
are: email addresses, domain names, legal entities, phone numbers, and
usernames (e.g., within a company).

We can think of the public-key infrastructure as implementing
the following (grossly simplified) API:
\[ \mathsf{IsKeyFor}(\vk, \texttt{name}) \to \zo.\]
That is, given a verification key $\vk$ and a name $\texttt{name}$, 
the public-key infrastructure gives a way to check whether this mapping
is valid.

% TODO: exmaples: chisel, meet in person, trusted source, blockchain

We now discuss some ways to implement this API.

\section{Option 1: Use verification keys as names}
One option is to just refer to everyone by the bytes of
their signature-verification key.
This way, there is no need to do a messy name-to-verification-key 
translation at all.

This is not practical for humans generally: it would be difficult
to remember your friends' names if you had to call them by 
random 32-byte strings!
However, some digital services such as Bitcoin indeed use verification
keys as identities: when you want to transfer Bitcoin to someone,
you send the coins to an account identified by their public key.
The public key \emph{is} name of that account.

Using keys as names has a two major problems:
\begin{itemize}
	\item Verification keys are hard to remember. Things like email addresses, domain names, kerberos usernames, phone numbers, and so on, are much easier for humans to remember.
	\item There is no way to update the name-to-key mapping. If you lose the secret key associated with your name/account, there is no way to ``update'' the key to a new value. In practice, people lose their secret keys all the time, so supporting key updates is critical in most systems.
\end{itemize}

% TODO: this introduction does not flow very well
% it might be good to have a section elaborating on the need to change keys a bit more.

\section{Trust on first use (TOFU)}
Another strategy is to avoid having any global mapping from names to verification keys.
Instead, a client can just accept the first verification key 
that it sees associated with a given name.
The secure shell system (\ttt{SSH}) uses TOFU for key management by default.

In particular, the key-validation logic looks like this:

\begin{framed}
\noindent
$\mathsf{keymap} \gets \{ \}$.

\medskip
\noindent
$\mathsf{IsKeyFor}(\vk, \texttt{name}):$ 
\begin{compactitem}
\item If $\mathsf{keymap}[\texttt{name}]$ is undefined:
      \begin{compactitem}
      \item Set $\mathsf{keymap}[\texttt{name}] \gets \vk$.
      \item Return true..
      \end{compactitem}

\item Else: Return $\mathsf{keymap}[\texttt{name}] == \vk$.
\end{compactitem}
\end{framed}

That is, the client will accept the \emph{first} verification key 
it sees associated with a particular name.
Later on, the client will only accept the same verification key
for that name.

TOFU is very simple to implement and provides a meaningful security
guarantees. 
There are two drawbacks:
\begin{itemize}
  \item If the first key that client receives for a particular name 
        is incorrect/attacker-generated, the attacker can forge signatures
        under that name.
  \item It is not clear with TOFU how to handle key updates. In most systems that use TOFU, whenever the sender's key changes, the system notifies the user and allows them to accept or reject the new key. The burden is then on the user to figure out whether the sender really did change their signing keypair, or whether there is an attack in progress.
\end{itemize}


----------------------------------

\section{Certificates}
Another option is to trust a few parties to reliably report verification keys for everyone else. In practice, this is most commonly used in web browsers for SSL keys: when you download Google Chrome or another browser, it will come with a preset list of \emph{Certificate Authorities} that the manufacturer has deemed trustworthy. 

When connecting to a new website, the server will provide a \emph{certificate} of the form $(\vk, \text{name}, \sig_{\text{CA}})$. The browser will accept that $\vk$ as corresponding to the given name if and only if the signature can be verified with one of the CA public keys that it has locally.

Importantly, no communication needs to happen between the browser and the CA in order to verify a $\vk$ of a new server: all that needs to happen is a local signature verification, checking that the signature provided was indeed created by one of the trusted CAs.

\marginnote{In order to use SSL on a website you own, you need to convince one of the certificate authorities to sign your $(\vk, \text{name})$ pair. To do so, the CA will have some protocol to follow---typically, you will send your $(\vk, \text{name})$ pair to the CA, who will then ask you to verify that you own the domain somehow. This verification may be uploading some secret file to your server, adding a new DNS record with a secret value, or something similar. Once this is done to the CA's satisfaction, the CA will reply with a signature over $(\vk, \text{name})$. This $(\vk, \text{name}, \sig_{\text{CA}})$ triplet then forms the \emph{certificate} that your website will advertise.}

This scheme in practice works quite well:
\begin{itemize}[noitemsep]
	\item The client only needs to store $\approx 100$, so the system scales well.
	\item A client can choose which CAs to trust (though in practice, this is totally up to manufacturers).
	\item No online interaction with the CA is required.
\end{itemize}

However, it is still far from a perfect solution:
\begin{itemize}[noitemsep]
	\item All of the CAs are ultimately trusted: if an attacker compromises some CA, they can generate certificates for any domain.
	\item Validation is weak
	\item If a server's private key gets stolen, there is no great plan---an attacker can impersonate them until the certificate expires.
\end{itemize}

\subsection{Revocation}
It may sometimes be the case that a verification key no longer belongs to the person that previously owned it. There are several possible reasons for this:
\begin{itemize}[noitemsep]
	\item The secret key corresponding to the verification key gets leaked
	\item A company may want to rotate keys, for example to update to a new cryptographic algorithm
	\item A website may go out of business and another entity buys their domain name
	\item Software bugs may lead to an insecure $(\sk, \vk)$ pair being generated in the first place
\end{itemize}

In a scheme that uses certificates, this seems like a hard problem: since there is no interaction with the CA to verify a certificate, there is no way for a CA to \textquote{take back} a certificate. There are again no excellent solutions to this, but there are a few strategies used in practice.

\paragraph{Expiration Dates}
The most practical solution to this is to add an expiration date to the generated certificate---if this expiration date has passed, the client will reject the certificate. This way, a server will need to re-authenticate to the CA that they own the name that they claim to own periodically. Therefore, an attacker that steals a secret key will only be able to use it for a certain amount of time.

\paragraph{Software Updates}
Another solution is for a browser to contain a list of revoked certificates. On every connection, the browser will check whether the provided certificate is in this local revocation list and refuse it if so. Since browsers today check for updates very frequently, this strategy can respond to a stolen secret key quickly. However, there is a large storage cost since now every browser needs to store this (potentially large) list of revoked certificates.

\paragraph{CA Revocation List}
To avoid depending on browser manufacturers to update this revocation list, another strategy is to ask the CA for it directly. One way to do this is similar to the above: periodically query the CA to download its updated revocation list and check that each certificate is not in this list. Another way called OCSP involves asking the CA on every new connection. However, this adds another request to the CA on the critical path to rendering.

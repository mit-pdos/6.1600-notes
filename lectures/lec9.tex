We have just constructed an encryption scheme with
weak (CPA) security: one that provided security
given that the adversary could see
\emph{encryptions} of messages of her choice.
The ``gold standard'' security notion for encryption
schemes allows the attacker to receive both encryptions
of messages of its choice 
\emph{and} decryptions of ciphertexts of its choice.
Our security notion then says that 
even an attacker with this power should not be
able to distinguish which of two chosen plaintext
message a given ciphertexts encrypts.

\section{Authenticated Encryption}

--------------------

Without authentication that a ciphertext was created by someone trusted, an adversary is free to tamper with the message and we will have no way of knowing. For example, if a client is communicating with a server, an adversary can observe one ciphertext, view the server's reaction, and compare it to the server's reaction to ciphertexts of his choice. Because the adversary is able to see the server's reaction (such as the length of its response or where it sends secondary requests to), this can allow the adversary to deduce the contents of the original message! 

In order to make our encryption scheme broadly applicable to all applications, we need to extend our definition of security to one called \emph{indistinguishability under chosen ciphertext attacks}.

\begin{definition}[Encryption Scheme CCA security (strong)]\label{defn:cca}
	An encryption scheme is CCA secure if every efficient adversary wins the following game with probability at most $\tfrac{1}{2} + \text{\textquote{negligible}}$:

  \begin{itemize}[noitemsep]
		\item The challenger samples $b \rgets \bin$ and $k \rgets \calK$.
    \item Polynomially many times: \quad \emph{// Chosen-plaintext queries}
          \begin{itemize}
            \item The adversary sends the challenger a message $m_i \in \calM$
						\item The challenger replies with $c_{m_i} \gets \Enc(k, m_i)$.
          \end{itemize}
    \item Polynomially many times: \quad \emph{// Chosen-ciphertext queries}
          \begin{itemize}
						\item The adversary sends the challenger a \emph{ciphertext} $c_j \notin \set{c_{m_0}, \ldots, c_{m_i}}$
						\item The challenger replies with $m_{c_j} \gets \Dec(k, c_j)$.
          \end{itemize}
    \item The adversary then sends two messages $(m^*_0, m^*_1) \in \calM^2$ to the challenger.
    \item The challenger replies with $c^* \gets \Enc(k, m^*_b)$.
		\item The adversary outputs a value $b' \in \bin$.
    \item The adversary wins if $b'=b$. 
	\end{itemize}
\end{definition}



We typically achieve this by concatenating the ciphertext output of the above scheme with a MAC using a \emph{different key}. \marginnote{It is important to use a different key for the encryption and the MAC here. Each application leaks some information about the secret key, and these different applications guarantee only that this leaked information will not compromise that application---they make no guarantees that the information leaked by one application will not compromise the security of some other application. In general, we must never share keys across different applications. However, in practice, it is sufficient to share a single key and derive two new pseudorandom keys as $\prf_k(0), \prf_k(1)$.} Importantly, we compute the MAC over the ciphertext---we encrypt \emph{then} MAC, rather than MAC the plaintext and then encrypt the concatenation of the two. Our final ciphertext to be sent then becomes $(ct = \Enc(k_\Enc, m), \MAC(k_\MAC, ct))$. This strategy is called Encrypt-then-MAC.

\begin{theorem}
	If an encryption scheme $(\Enc, \Dec)$ is CPA secure and MAC is secure (existentially unforgeable against adaptive chosen message attacks), then Encrypt-then-MAC is CCA secure.	
\end{theorem}

\section{AES-GCM (Galois Counter Mode)}
In practice, authenticated encryption is most commonly done using a scheme that combines the encryption and the MAC, called AES-GCM. However, they are able to improve performance by doing this using a one-time MAC that is not secure! Importantly, the MAC they use is not secure if the attacker ever sees a tag. To do this, the scheme \emph{masks} the final output of the MAC with yet another one-time pad: the \textquote{tag} that is revealed is actually $\text{tag} \xor \AES(k, iv || 0)$.

% TODO: clarify this
The scheme makes use of a finite-field multiplication to implement this insecure MAC. In particular, it uses a function $M_H: \bin^{128} \rightarrow \bin^{128}$ which is a multiplication by $H = \AES(k, 0)$ in a finite field of size $2^{128}$.
\begin{itemize}
	\item Computes $[ct_1, ct_2, \ldots, ct_n]$ for each block $i$ by computing $m_1 \xor \AES(k, iv || i)$.
	\item Computes $t = M_H(M_H(\ldots), M_H(ct_2)), M_H(ct_1))$
	\item Computes $t' = t \xor \AES(k, m_0)$

\end{itemize}
% TODO: finish
% TODO: diagram is pretty important here

So far, we have talked about encryption systems that require
the sender and recipient to \emph{share a secret key}.
In this chapter, we discuss how the sender and recipient
can agree on a shared secret even if they only ever communicate
over an open (insecure) network.

A key-agreement scheme over keyspace $\calK$ is defined by efficient functions $(\Gen, \Derive)$:
\begin{itemize}[noitemsep]
  \item $\Gen() \to (\sk, \pk)$. The $\Gen$ algorithm 
    generates a secret key and a public key for one party.
  \item $\Derive(\sk_A, \pk_B) \to k$. The $\Derive$ algorithm
    takes as input one party's secret key $\sk_A$ and the
    other party's public key $\pk_B$ and outputs a shared
    key $k \in \calK$.
\end{itemize}


\paragraph{Correctness.} 
Correctness for a key-agreement scheme just says that the two parties
should always agree on the same shared secret:

\begin{definition}[Key Agreement Correctness]
We say that a key-agreement scheme is \emph{correct} if
for all 
$(\sk_A, \pk_A) \gets \Gen()$ and
$(\sk_B, \pk_B) \gets \Gen()$, it holds that: 
\[ \Derive(\sk_A, \pk_B) = \Derive(\sk_B, \pk_A). \]
\end{definition}

\paragraph{Security.}
The standard notion of security for a key-agreement scheme
only considers \emph{passive attacks}:
we consider adversaries that can view the
network traffic but cannot modify it.
In practice, we can combine key-agreement
schemes with authentication schemes (e.g., digital signatures)
to prevent active attacks by in-network adversaries.

Our security definition for key agreement says that even
if an adversary sees both parties' public keys, it should
not be able to distinguish the shared secret from random.
That is, the following probability distributions
$D_\text{real}$ and $D_\text{random}$ should be 
computationally indistinguishable:\marginnote{When we
say that two distributions are \emph{computationally indistinguishable},
we mean that if we give the adversary a sample from one or the other,
it can guess which sample it got with probability at most $1/2 + \text{``negligible''}$.}
\begin{align*}
  D_\text{real} &\deq \left\{ 
(\pk_A, \pk_B, k) \colon  \begin{aligned}
  (\sk_A, \pk_A) &\getsr \Gen()\\
  (\sk_B, \pk_B) &\getsr \Gen()\\
  k &\getsr \Derive(\sk_A, \pk_B)
\end{aligned}
\right\} \\
  D_\text{random} &\deq \left\{ (\pk_A, \pk_B, k) \colon  \begin{aligned}
  (\_, \pk_A) &\getsr \Gen()\\
  (\_, \pk_B) &\getsr \Gen()\\
  k &\getsr \calK 
\end{aligned}
  \right\}
\end{align*}


\section{Diffie-Hellman key exchange}
We now give a simple and beautiful key-exchange protocol, 
due to Diffie and Hellman.

The version we will see uses large primes $p$ 
and $q$ a public parameters, along with a number $g \in \Z^*_p$,
called the ``generator.''
(\textbf{Warning:} The parameters $p$, $q$, and $g$ must have
some particular relation. So do not attempt to pick these parameters
yourself.)
Typically, we will have $p \approx q \approx 2^{2048}$.
\marginnote{For a prime $p$, the 
notation $\Z^*_p$ just denotes 
the non-zero integers modulo $p$.
So when we write $ab \in \Z^*_p$,
we mean $a \cdot b \bmod p$.}

The keyspace of the Diffie-Hellman scheme is $\calK = \Z^*_p$
and the algorithms are as follows:
\begin{itemize}[noitemsep]
  \item $\Gen() \to (\sk, \pk)$.
    \begin{itemize}[noitemsep]
      \item Sample $\sk \getsr \{1, \dots, q\}$.
      \item Set $\pk \gets g^{\sk} \in \Z^*_p$.
      \item Output $(\sk, \pk)$.
    \end{itemize}

  \item $\Derive(\sk_A, \pk_B) \to k$.
    \begin{itemize}[noitemsep]
      \item We have $\sk_A \in \{1, \dots, q\}$ and $\pk_B \in \Z^*_p$.
      \item Output $k \gets (\pk_B)^{\sk_A} \in \Z^*_p$.
    \end{itemize}
\end{itemize}

Before we argue correctness and security, let us consider
the computational efficiency of the scheme:

\paragraph{Efficiency.} In order for the algorithm to be useful,
Alice and Bob must be able to compute $g^x \in \Z^*_p$ efficiently,
for $x \in \{1, \dots, q \approx 2^{2048}\}$.
However, trying to compute $g^x$ where $x$ is 2048
bits long naively would certainly not be
efficient: it would require $x \approx 2^{2048}$ multiplications!
However, we can compute this exponentiation much more efficiently using
the following strategy:
\begin{itemize}[noitemsep]
  \item \textbf{Compute powers of $g$.}
        Write $\ell \gets \lceil \log_2 p \rceil$.
        Then compute $(g, g^2, g^4, g^{8}, g^{16}, \dots, g^{2^\ell})$,
        where all of these are in $\Z^*_p$.
        It is possible to compute $g^{2^{i}}$ with a single multiplication
        modulo $p$ as $g^{2^i} = (g^{2^{(i-1)}})^2 \in \Z^*_p$.
        So this step takes only $\ell = 2048$ multiplications.
        \marginnote{In many applications, the generator $g$ is fixed in advance.
        In this case, the implementation can precompute and store these powers of $g$.}
  \item \textbf{Compute exponentiation.}
        Write the bits of the exponent as $x = x_0 \cdots x_{\ell-1}$.
        Then compute:
        \[ g^x = g^{\sum_{i = 0}^{\ell-1} x_i 2^i} = \prod_{i=0}^{\ell-1} x_i(g^{2^i}) \in \Z^*_p\] 
        This step again takes only $\ell$ multiplications.
\end{itemize}


\paragraph{Correctness.}
Correctness holds since $g^{xy}=g^{yx} \in \Z^*_p$ for all $x,y \in \Z$:
\begin{align*}
  \Derive(\sk_A, \pk_B) = (\pk_B)^{\sk_A} = (\pk_A)^{\sk_B} = \Derive(\sk_B, \pk_A).
\end{align*}


\paragraph{Security.}
To argue security, we must rely on a new computational assumption:
essentially we just assume that the key-agreement scheme is secure.

\begin{definition}[Decision Diffie-Hellman assumption]
For $p$, $q$, and $g$, the following distributions are 
computationally indistinguishable:
  \[ 
  \{ (g, g^x, g^y, g^{xy}) \in (\Z^*_p)^4\colon x, y \getsr \{1, \dots, q\}\}
  \approx_c
  \{ (g, g^x, g^y, g^z) \in (\Z^*_p)^4 \colon x, y, z \getsr \{1, \dots, q\}\}
  \]
\end{definition}

\section{Background: Group theory}
The simplest and most commonly used key-exchange protocol uses
a mathematical concept called a \emph{group}.
A group $\G$ is a set of elements along with an operator
``$\cdot$'' that takes two group elements $g, h \in \G$
and returns a third group element $g \cdot h \in \G$.
A group 




\marginnote{So far, we have been able to construct our cryptographic entities from constructs like a PRF, which meant that we could use \textquote{unstructured} algorithms like AES to compute them. We so far only know how to construct key-exchange schemes from 
more structured problems (e.g., based on number theory).}

\section{Constructing a key agreement protocol}

This scheme first requires the two parties to decide on some large (2048 bits) prime number $p$ and a random element $g \in \Z_p^*$, where $\Z_p^* = \set{1, 2, \ldots, p-1}$. \marginnote{In practice, $p$ and $g$ are predetermined as part of the standard and used for all instances of the key exchange.}

\begin{enumerate}[noitemsep]
	\item Alice chooses a random value $x \in \Z_p^*$ and sends $g^x \mod p$ to Bob.
	\item Bob chooses a random $y \in \Z_p^*$ and sends $g^y \mod p$ to Alice.
	\item Alice and Bob both then compute $K = g^{xy} \mod p$.
		\begin{itemize}
			\item Alice computes $K = G_1(x, g^y) = (g^y)^x = g^{xy}$
			\item Bob computes $K = G_2(y, g^x) = (g^x)^y = g^{xy}$
		\end{itemize}
\end{enumerate}


\paragraph{Basic Group Theory}
Each element $g \in \Z_p^*$ has order $\text{Order}(g) = \abs{\set{g^1, g^2, \ldots }}$. For any of these elements, a theorem states that $\text{Order}(g)$ divides $\abs{\Z_p^*} = p-1$. Importantly, this guarantees that $g^{p-1} = 1$.

\section{Diffie-Helman Security}
To prove the security of the scheme, we will first prove \emph{weak security}---that it is hard to learn the entire key from the messages of the key agreement protocol.\marginnote{When we say that it is \emph{hard} to guess the key, we mean that the probablity that any adversary can find $K$ is at most \textquote{negligible}.} We settle here because it is possible to convert a weak key (where some bits may be known but the whole key is hard to learn) into a strong key---to do so, compute $k_\text{strong} = H(k_\text{weak})$. Importantly, if $H$ is modeled as a random oracle, because it is (computationally) hard to learn the key $k_\text{weak}$, the value $H(k_\text{weak})$ is computationally distinguishable from random.

To prove this weak security, we will need an assumption called the \emph{Computational DH Assumption} (CDH). This assumption states that given $g^x$ and $g^y$, it is hard to compute $g^{xy}$.

In particular, this relies on the \emph{Discrete Log Assumption}: given $p, g$, and $g^x$, it is hard to compute $x$. However, there are some attacks on this problem:

\begin{enumerate}
	\item The most basic attack is to enumerate all $p$ possible values of $x$ and check whether the corresponding $g^x$ matches. This will take time $p \approx 2^{2048}$.
	\item A much better attack is the Number Field Sieve, which is able to compute $x$ in time $2^{O(\log p)^{\frac{1}{3}}}$---sub-exponential time! The existence of this attack is the reason we require so many bits for $p$---otherwise, this problem would be feasibly solveable.
	\item For more generic (non-$\Z_p^*$) groups, there is an algorithm called Giant Step Baby Step that is able to compute $x$ in time $\sqrt{p}$.
\end{enumerate}

However, the discrete log assumption does not imply the computational DH assumption. However, the only methods we know of to try to compute $g^{xy}$ from $g^x$ and $g^y$ rely on solving the discrete log problem. Therefore, we assume that the computational DH assumption holds. 

\subsection{Without Random Oracle Model}
In order to achieve strong security for our generated key with the above assumption, we relied on a hash function that we modeled as a random oracle. However, this random oracle model is obviously not accurate. If we want to achieve strong security from Diffie-Helman \emph{without} modeling a hash function as a random oracle, we need to assume the \emph{Decisional DH Assumption} (DDH).

For Diffie-Helman to be secure, we would like that $(g^x, g^y, g^{xy}) \cong (g^x, g^y, g^z)$ where $x, y, z \rgets \set{1, \ldots, p-1}$. And indeed, the DDH assumption is exactly this. Unfortunately, in general (for random $g$ and $p$) DDH is false. Since our $\abs{\Z_p^*} = \abs{\set{1, \ldots, p-1}}$, and $p$ is prime, $p-1$ must not be prime. This means that the \emph{order} of $\Z_p^*$ is even---certainly not prime. We know that groups of prime order do not have \emph{subgroups}, but groups that are not of prime order do not carry this guarantee.

To distinguish $g^{xy}$ from $g^z$ for random $z$, we will check if $xy$ is even. This may seem like it relies on breaking the discrete log assumption, but in fact we can much more efficiently check if an element is in the \emph{quadratic residue} of a group. Crucially, the probability that $xy$ is even is $\tfrac{3}{4}$, while the probability that $z$ is even is $\tfrac{1}{2}$. Given $(g^x, g^y, g^z)$, our attack will output 0 if $g^z \in QR$ and 1 otherwise, where 0 indicates that $z = xy$ and 1 indicates that $z$ is random.

To determine if a value $g^z$ is in the set of quadratic residues of $g$, we will check whether $(g^z)^{2^{i-1}}$ is equal to 1.

However, there are certain selections of $g$ and $p$ for which we believe that DDH does hold. In particular, if we choose $p$ to be a \emph{safe prime} where $\frac{p-1}{2}$ is prime and we choose $g$ to itself be a quadratic residue (so that $g^z$ is always a quadratic residue), we believe that DDH holds.
